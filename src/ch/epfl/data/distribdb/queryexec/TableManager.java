package ch.epfl.data.distribdb.queryexec;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import ch.epfl.data.distribdb.lowlevel.DatabaseManager;

/**
 * Manage Temporary Tables that get created 
 * by the execution of query plans  
 * Used to clean tables generated by running
 * the StepExecutor
 *  
 * @author Amer C <amer.chamseddine@epfl.ch>
 */
public class TableManager {
	/**
	 * List of temporary tables used throughout the 
	 * execution of the steps of the distributed 
	 * query plan
	 */
	List<String> tempTblNames = new LinkedList<String>();
	
	/**
	 * Constructor - initializes the object 
	 */
	public TableManager() {
	}

	/**
	 * Cleans Temporary Tables on the nodes mentioned 
	 * in the given list of nodes
	 * 
	 * @param DatabaseManager
	 * @param List<String> nodeIds
	 * @throws SQLException
	 * @throws InterruptedException
	 */
	public synchronized void cleanTempTables(final DatabaseManager dbManager, final List<String> nodeIds) 
			throws SQLException, InterruptedException {
		if(tempTblNames.isEmpty())
			return;
		
		final ExecutorService pool = Executors.newCachedThreadPool();
		
		final List<Callable<Void>> tasks = new ArrayList<Callable<Void>>();
        final List<SQLException> exceptions = Collections.synchronizedList(new ArrayList<SQLException>());
        
		for (final String nodeId : nodeIds) {
			tasks.add(new Callable<Void>() {
				@Override
				public Void call() throws Exception {
                    try {
                    	StringBuilder sb = new StringBuilder();
                    	for(String tbl : tempTblNames) {
                    		sb.append("DROP TABLE IF EXISTS " + tbl + ";");
                    	}
                    	dbManager.execute(sb.toString(), nodeId);
                    } catch (SQLException e) {
                        exceptions.add(e);
                    }
                    return null;
				}
			});
		}
		
        pool.invokeAll(tasks);
        pool.shutdown();
        
        if (!exceptions.isEmpty()) {
            throw exceptions.get(0);
        }
        
        tempTblNames.clear();
	}
	
	/**
	 * Cleans Temporary Tables on the nodes mentioned 
	 * in the given list of nodes
	 * 
	 * @param List<String> nodeIds
	 * @throws SQLException
	 * @throws InterruptedException
	 */
	public void cleanAllTmpTables(final DatabaseManager dbManager, final List<String> nodeIds) 
			throws SQLException, InterruptedException {
		final ExecutorService pool = Executors.newCachedThreadPool();;
		final List<Callable<Void>> tasks = new ArrayList<Callable<Void>>();
        final List<SQLException> exceptions = Collections.synchronizedList(new ArrayList<SQLException>());
		for (final String nodeId : nodeIds) {
			tasks.add(new Callable<Void>() {
				@Override
				public Void call() throws Exception {
                    try {
                    	ResultSet rs = dbManager.fetch("" +
                    			"SELECT tablename " +
                    			"FROM pg_catalog.pg_tables " +
                    			"WHERE tablename LIKE 'tmp_%'" , nodeId);
                    	StringBuilder sb = new StringBuilder();
                    	while(rs.next()) {
                    		sb.append("DROP TABLE " + rs.getString(1) + ";");
                    	}
                    	dbManager.execute(sb.toString(), nodeId);
                    } catch (SQLException e) {
                        exceptions.add(e);
                    }
                    return null;
				}
			});
		}
        pool.invokeAll(tasks);
        pool.shutdown();
        if (!exceptions.isEmpty()) {
            throw exceptions.get(0);
        }
	}

	/**
	 * Builds temporary unique 
	 * names out of a relation name
	 * EDIT: we don't use the relation name 
	 * anymore because the name could grow very 
	 * bug after several SuperDuper steps 
	 * 
	 * @param original relation name
	 * @return new temporary unique name
	 */
	public synchronized String generateTmpTblName(String orig) {
		do{
			orig = "tmp_" + new Random().nextInt(1000000);
		} while(tempTblNames.contains(orig));
		tempTblNames.add(orig);
		return orig;
	}

}
